# RPC实战与核心原理

##  基础

如何设计一个协议：

- 魔术位：表明这是什么协议
- 整体长度
- 协议头长度：为了保证协议的可扩展性，协议头长度不能固定死
- 协议版本
- 消息ID：用于关联请求和对应的响应
- 序列换方式：报文payload采用的序列化方式
- 消息体

为什么rpc不直接使用http协议：

http协议无法实现请求和响应的关联，http协议本身是无状态的，http1.1虽然支持长连接，但服务端返回的多个请求很可能乱序抵达客户端的，此时如果客户端是同步阻塞等待着返回的那是没有问题的，但如果是异步的，那客户端就无法知道返回的响应对应的是哪个请求，因此rpc使用私有协议(rpc中通过在协议中带上一个消息id来保证请求和响应一一对应)

序列化方式：

- JDK原生: `ObjectOutputStream`和`ObjectInputStream`

![jdk原生序列化方式](./pics/jdk_stream.jpeg)

- json: 进行序列化时占用较大的额外空间，json本身没有类型，像java强类型语言就必须通过反射解决
- hessian: 动态类型的(不需要手动指定类型)，二进制的，因此更加紧凑，生成的字节数更少，性能也更好
- protobuf: 需要定义IDL(Interface description language)，因为在IDL中定义了类型，所以序列化和反序列化速度很快，无需通过反射去获取类型，序列化后字节数很少

序列化协议权衡：性能，字节数(网络传输数据量)，通用性和兼容性(跨平台，跨语言，支持各种对象类型)，安全性(最为重要)

## rpc架构

![rpc架构](./pics/rpc_structure.jpeg)

### 服务发现

为什么不通过dns实现服务发现：

因为为了提升性能和降低dns服务压力，dns采用多级缓存，一般配置的缓存时间较长，当某个服务节点下线或新服务节点扩容上线，其他服务是很难及时感知到的

即使设计成通过dns拿到负载均衡机器的ip，然后由负载均衡服务完成流量路由，也是不合适的，因为首先经过负载均衡就多了一次网络传输，此外负载均衡进行添加或移除节点一般都需要手动操作，会有延迟

为什么不直接使用zookeeper：

直接使用zookeeper本身没有什么问题，首先在zookeeper创建服务目录，然后服务提供者注册节点信息，再然后服务调用者订阅该服务目录并从zookeeper这获取到服务节点信息，并且当服务目录下节点信息发生变更后zookeeper会通知订阅的服务方

当zookeeper本身性能不佳，当连接到zookeeper节点数特别多，对zookeeper读写非常频繁，且存储的目录达到一定数量后，zookeeper会不再稳定，cpu飙升最终宕机

CAP: 一致性(Consistency)，可用性(Availability)，分区容错性(Partition tolerance)

zookeeper实现的服务发现是强一致的，zookeeper集群中任何节点数据发生更新都需要通知到其他zookeeper节点同步更新，以保证每个节点数据的强一致，但也造成了zookeeper性能下降

在服务发现中并不真正需要强一致(CP)，最终一致性(AP)是更好的选择，因为新服务刚上线没有流量立刻打过来也没啥问题，而服务下线rpc本身也会做重试，因此最终一致性更优

采用消息总线机制实现最终一致性
- 注册数据全量缓存在每个注册中心内存中，通过消息总线完成数据同步
- 当一个注册中心节点收到服务节点注册时，会生成一个消息推送给消息总线，每个消息都有个递增的版本号
- 消息总线会主动推送消息给每个注册中心，注册中心自己也可以定时去拉去消息，注册中心只接受版本号大于本地的版本号的消息，小于的直接丢弃，从而实现最终一致性
- 服务调用者可以从注册中心拿到指定服务的所有注册信息，并可以缓存在本地内存中
- 采用推拉模式，服务调用者可以及时从注册中心拿到服务注册信息的变化情况，并和内存中的缓冲数据合并

### 健康监测

机器纬度 + 应用纬度

机器纬度：可以通过定时心跳请求来判断节点是否可用，心跳请求频率不宜过高，不然会给服务器造成压力，但也不宜过低，会导致不能及时发现问题机器，注意，心跳请求的节点不能和目标节点在同一物理机上，否则如果机器挂了，那么心跳也挂了，就无法感知到了

应用纬度：通过可用率判断该节点是否健康，可用率 = 某一时间段内 (成功次数 / 总次数)

### 路由策略

路由策略不适合放在注册中心，因为注册中心负责的是数据一致性，如果把大量复杂逻辑计算也放在注册中心后，当连接的节点数变多后就会导致注册中心压力很大

因此路由策略更适合放在服务调用端中计算，注册中心将路由规则下发给调用端，调用端在从注册中心这拿到所有注册节点信息后，根据规则(比如IP路由，参数路由：根据不同用户id)计算出可以请求的路由节点

```txt
rpc调用流程：
调用端 -> 从注册中心获取所有注册节点信息和路由规则 -> 容错策略 -> 路由策略 -> 负载均衡 -> ...
```

因为路由本质上是节点分组(不同节点分到不同的set中)，流量隔离(泳道)，因此不论是打标签还是分流都天然适合在路由策略中做

此外，虽然路由策略是在调用方(上游)做的选择出服务提供方(下游)，这是符合rpc调用机制的，但不符合团队协作，比如下游服务希望修改路由策略或者新增路由策略，这就要求所有上游同时修改，并且必须先于下游服务先上线，一般来说是很难推动上游配合的，因为这对于上游不但没有收益还会面临风险，所以路由策略要么在初期就能够考虑周全，要么抽象成可配置的信息，动态下发
