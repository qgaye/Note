# 数据库(MySQL)

## ACID

- 原子性(Atomicity)：一个事务里的所有操作要么全都执行成功要么失败后全部回滚
- 一致性(Consistency)：数据库的完整性约束不被破坏，事务执行前后都是数据合法的状态
- 隔离性(Isolation)：并发执行的事务之间相互影响的程度，最严格的串行化表示事务间不会互相干扰
- 持久性(Durability)：事务一旦提交，对数据库的修改操作是永久的，不会被其他操作或故障所影响

MySQL实现ACID机制：

- 原子性：undo log
- 一致性：原子性，隔离性，持久性三者共同来保证一致性
- 隔离性：MVCC和锁机制
- 持久性：redo log

## 隔离级别选择

MySQL默认隔离级别是可重复读(RR)，而Oracle默认隔离级别是提交读(RC)

为什么MySQL默认隔离级别是可重复读：

因为早期MySQL中binlog只有statement一种形式，即直接保存提交的sql，因此sql语句执行的顺序就很关键，如果乱序就会导致数据异常(比如auto_increment执行顺序不同会导致值不同)，因此就需要在可重复读的隔离级别下通过间隙锁来保证sql执行顺序，但是现在binlog支持row格式，也就是不再一定需要保证sql执行顺序了

因此MySQL数据库也推荐使用提交读的隔离级别：
- 提交读相较于可重复读而言，没有了next-key lock，因此发生死锁的可能性低了很多
- 在提交读的隔离级别下当条件未命中索引则不会像可重复读一样直接锁住全表，而是会释放掉不满足条件的记录

理论上在真实业务中，插入的数据被读到往往没有什么大问题

## buffer pool

buffer pool（缓冲池）即类似一个缓存机制，以避免每次查询都需要进行磁盘IO

预读：MySQL中是以页作为数据存储的基本单位，页的大小一般为16K。MySQL在读取时不是仅仅只读需要的那一条，而是将整个页全部加载进buffer pool，因为该条数据的周围数据大概率会被继续读取（局部性原则），这样提前加载可以有效减少磁盘IO

但是buffer pool是会满的，MySQL使用新老生代的LRU算法来有效避免普通LRU算法带来的缓冲池污染的问题

新老生代LRU算法：

整个buffer pool前70%被分为新生代，后30%被分为老生代
- 当读取的数据不在buffer pool中：
    - 查询出该数据，直接插入到老生代的head，如果buffer pool满了则淘汰掉老生代中的tail（也就是整个buffer pool的tail）再插入到老生代的head
- 当读取的数据在buffer pool中：
    - 如果数据位于新生代中，则将它移动到到新生代的head（也就是整个buffer pool的head）
    - 如果数据位于老生代中，并且该数据在老生代中停留时间大于1s（由参数控制）时，移动到新生代的head，否则保持原先位置不变

当批量扫描大量数据时，因为移动到head是要求数据在老生代中达到一定停留时间的，所以这些非热点数据只会在老生代中不断被替换，而不会影响到处在新生代中真正的热点数据

## redo log

当对数据进行增删改操作时，首先需要将数据从磁盘上读取到buffer pool(相当于缓存)中，然后在buffer pool中进行修改，但此时buffer pool上被修改过的数据页就和磁盘上的数据页不一致，这些数据页被称为脏页。当数据库崩溃后，这些脏页的数据因为没有被持久化到磁盘就会丢失，因此InnoDB设计了redo log，每次数据更新后将数据页发生的修改信息持久化到磁盘，从而保证在奔溃后可以通过redo log直接恢复数据页上的信息

- redo log优势在于其每次操作是一个顺序IO，相较于每次直接将脏页刷入磁盘的随机IO，性能更佳
- redo log作用主要用于数据重做，即脏页数据能在奔溃后恢复到磁盘，而binlog主要用于不同数据库间数据同步
- redo log记录的是数据页上的变化信息，而不是像binlog中存储的是具体sql
- redo log在整个事务执行过程中都会不断的持久化到磁盘(定时刷盘或组提交)，而binlog则是在整个事务提交后才会落盘
- redo log在磁盘上是指定存储到`ib_logfile1/2/3...`文件中，文件数量和大小是配置的，因此如果一旦redo log文件满了，就需要将记录应用到真正的数据磁盘上(即脏页落盘)，redo log file中有一个checkpoint，checkpoint之后表示还未刷盘的redo log，即数据库奔溃后需要恢复应用的redo log，而binlog是无限追加写到文件中的

因为未提交和回滚的事务也都记录了redo log，因此当恢复时对这些事务需要特殊处理：在InnoDB进行恢复时，会重做所有事务的redo log，接着对未提交的事务执行undo log
- 因为未提交的事务在恢复时需要执行undo log，因此undo log会被看作数据一起被记录在redo log中，当发现恢复的事务是未提交的，那就会执行undo log来回滚这些操作
- 对于回滚的事务，会直接在redo log中与本身事务相反的操作，比如插入数据在回滚后会在redo log中接着插入条删除数据的记录

## 半同步下主从切换问题

半同步模式下，master会将binlog发送给slave，并在接收到一台slave的ack确认后才返回确认给客户端，整个过程实质上只是保证了binlog能够被一台slave接收到(只要收到一台slave的ack就返回，因此无法保证所有slave都已经收到binlog了)，但是slave接收到binlog后将其真正应用到自身数据库上是需要时间的，那么这时如果master崩了，切换到slave时也不能够立刻投入使用的，因为此时存在部分master传来的binlog还没有应用的问题，如果直接切换，那么存在数据不一致的问题

总结：即使在半同步下主从切换也是需要保证从库将所有binlog都应用完成后才能说明主从数据一致了，如果将业务流量直接切换到从库，那么auto_increment主键是很容易出现冲突问题的
