# 操作系统

## 进程/线程/协程

进程：资源分配的基本单位
线程：CPU调度的基本单位

进程如果挂了，那么是不会影响到别的进程的，而线程如果挂了，那么这个进程也挂了

在Linux中进程和线程都用`task_struct`来表示，唯一的区别就是进程的mm(指向的内存区域)和files(输入流/输出流)是不同的，而线程是相同的

虽然进程和线程在调度时都需要切换到内核态，但因为线程是共享内存的，因此一个进程下的多个线程间切换就无需刷新页表和TLB，只需要刷新一下寄存器即可(总结：进程间的切换往往会导致CPU缓存失效，快表TLB无法命中的问题)

协程：无论线程还是进程的切换都需要由用户态切换到内核态由操作系统完成，而协程则完全由编程语言来实现和调度，且切换在用户态完成，即用户态的线程

进程线程上下文切换：上下文切换指的是将该进程的CPU寄存器/程序计数器中的值保存到内存中，下次使用时再恢复到CPU寄存器/程序计数器中，这个操作有两部分耗时，内核态到用户态间的切换耗时和寄存器的状态保存耗时

## 进程调度算法

- FCFS：先来先服务，先进先出，但会导致短进程耗时过长
- SPF：短进程优先，但会导致长进程一直得不到CPU资源
- HRRN：高响应比优先算法，短进程和长进程都能考虑到，响应比 = (等待时间 + 执行时间) / 执行时间，响应比高的先执行
- 时间片轮转法：进程在时间片用完后被中断放入队尾，让下一个进程执行时间片时间，但进程切换是消耗CPU的，因此时间片大小需要特别注意
- 优先级调度算法：按进程的优先级选择执行顺序
- 多级反馈队列调度算法：设置多个辅助队列，每个队列优先级不同，且优先级高的时间片越小，当一个进程到来时先进第一队列(先进先出)，在时间片内如果无法执行完就到第二队列(先进先出)，以此类推，且只有当第一队列中没有进程后第二队列才能执行，这样无需提前知道进程的运行时间还能满足各类型进程的需求

## 进程间通信方式

- 管道：linux中`|`就是个匿名管道，管道的通信是单向的，并且传输数据的进程必须等接受数据的进程接受完数据后才能返回，效率低下
- 消息队列：进程需要传输的消息放到消息队列中，获取数据的进程去消息队列中拿，从而使得传输数据的进程可以立即返回，但发送数据到消息队列是需要拷贝到消息队列中的
- 共享内存：两个进程虚拟地址映射到同一块物理地址上，两个进程有着独立的虚拟内存空间，却映射到了相同的物理内存上
- 信号量：类似Java中Semaphore，和共享内存配合使用来控制共享内存并发访问问题
- Socket：套接字通信，可以解决不同机器上的进程间通信

## 页面置换算法

- 最佳置换算法(OPT)：优先淘汰未来不再会被使用到的页面，但是因为无法预知哪些页面不再会被使用，因此该算法无法实现
- 先进先出置换算法(FIFO)：优先淘汰最先进入内存的页面，但会存在Belady异常(分配的物理块越多但出现缺页中断的次数反而增加)
- 最近最久未使用置换算法(LRU)：优先淘汰最长时间没被访问过的页面，但需要寄存器和栈的硬件支持
- CLOCK：每个页面都有一个访问位，当该页被访问就+1，淘汰时扫描所有页的访问位，优先淘汰访问位为0的页，如果没有找到则再次扫描淘汰访问位为1的页，知道淘汰掉一个为止

## 磁盘寻道算法

- 先来先服务算法(FIFO)：依次处理服务队列中每一个寻道请求，但会导致磁头移动的平均距离比较大
- 最短寻道时间算法(SSTF)：优先处理距离当前磁头所在磁道最近的磁盘号，但会导致距离当前磁道较远的磁盘号请求一直无法被服务，即饥饿现象
- 扫描算法(SCAN，电梯算法)：磁头必须移动到最外侧磁道后才能反向向内移动，在向内移动到最内侧后才能再反向向外扫描
- LOOK算法：相较于SCAN算法，磁头不再必须移动到最外/最内侧磁道后才能返回，而是移动到某处且这处之后不再有需要访问的磁盘号就立即反向移动
- C-SCAN/C-LOOK循环算法：相较于SCAN和LOOK，当移动到一侧后，不再掉头反向查找服务，而是直接调换到另一侧头开始继续服务

## 用户态/内核态

在CPU的所有指令中有一些指令是很危险的，比如清内存等，因此不能允许所有程序都能使用这些指令，因此要执行这些特权指令就必须由用户态切换为核心态

用户态和核心态在程序状态字(寄存器)中通过0/1来标志，用户态到核心态也就是个设置程序状态字标志的操作

中断是CPU从用户态到核心态的唯一途径，发生中断就意味着需要操作系统介入进行工作，比如进程切换，IO操作等x

既然由用户态到核心态只能通过中断进行，但是中断也分成内中断和外中断：
- 内中断
  - 自愿中断：也就是系统调用，用户态进程申请执行操作系统提供的特权指令
  - 强迫中断：也就是程序在用户态下发生了事先不可知的异常，这就会触发切换到内核态由操作系统进行处理
- 外中断：比如外设中断，当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时CPU就会暂停执行下一条即将要执行的指令，切换到内核态由操作系统去执行中断信号对应的处理程序

## 虚拟内存/分页/分段

分页和分段区别在于分的粒度不同，但都是为了更好的管理内存

当没有分页或分段的虚拟内存技术，程序加载到内存要求一段连续的内存地址，那么就会产生如下问题：
- 必须有连续的满足程序大小的空间地址
- 地址空间不隔离，进程可能会操作到别的进程的内存地址
- 程序运行时的地址不确定，如果在程序中写死操作某个物理地址，但无法保证程序每次加载进内存都在这块物理地址处
- 内存使用率低下，当程序移出内存后，如果这块区域太小无法容纳接下来的程序要求，那么就会造成内存碎片，此外应该可以将有些暂时不用的程序移到磁盘，让别的程序加载进内存(缺页中断)

分页/分段引入了虚拟地址空间的概念，通过将虚拟地址映射到物理地址上，从而程序只需要关心虚拟地址即可，但是分段模式下映射的还是一整块连续的内存地址(分段解决了地址空间不隔离和运行时地址不确定的问题)，但内存使用率低下的问题还是没能解决，而分页的方式，将虚拟地址分为页号和页内偏移量两部分，将内存的最小单元由一个程序所需的连续内存段转为粒度更细的页，从而有效解决了内存碎片的问题

分页通过页表记录虚拟地址和物理地址间的映射关系，页表存储在每个进程PCB中，这个页表是该进程独有的，当CPU读取数据时，需要先读一次内存中的页表，找到物理地址后才能访问到真正的数据，因此数据读取需要两次内存读取，于是就在CPU缓存中维护了个TLB块表，当查询虚拟内存地址时会先查TLB快表，如果不在再去内存中查询页表，从而加快速度

虚拟内存地址大于物理内存地址时，其实就是虚拟地址在页表中映射到了disk硬盘上，这时会发生缺页中断，此时切换到内核态，内核从磁盘中找到数据加载到内存中，并将物理地址重新填写到页表中，再重新寻址

![内存段](./pics/memory.png)
