# 操作系统

## 进程/线程/协程

进程：资源分配的基本单位
线程：CPU调度的基本单位

进程如果挂了，那么是不会影响到别的进程的，而线程如果挂了，那么这个进程也挂了

在Linux中进程和线程都用`task_struct`来表示，唯一的区别就是进程的mm(指向的内存区域)和files(输入流/输出流)是不同的，而线程是相同的

虽然进程和线程在调度时都需要切换到内核态，但因为线程是共享内存的，因此一个进程下的多个线程间切换就无需刷新页表和TLB，只需要刷新一下寄存器即可(总结：进程间的切换往往会导致CPU缓存失效，快表TLB无法命中的问题)

协程：无论线程还是进程的切换都需要由用户态切换到内核态由操作系统完成，而协程则完全由编程语言来实现和调度，且切换在用户态完成，即用户态的线程

进程线程上下文切换：上下文切换指的是将该进程的CPU寄存器/程序计数器中的值保存到内存中，下次使用时再恢复到CPU寄存器/程序计数器中，这个操作有两部分耗时，内核态到用户态间的切换耗时和寄存器的状态保存耗时

## 进程调度算法

- FCFS：先来先服务，先进先出，但会导致短进程耗时过长
- SPF：短进程优先，但会导致长进程一直得不到CPU资源
- HRRN：高响应比优先算法，短进程和长进程都能考虑到，响应比 = (等待时间 + 执行时间) / 执行时间，响应比高的先执行
- 时间片轮转法：进程在时间片用完后被中断放入队尾，让下一个进程执行时间片时间，但进程切换是消耗CPU的，因此时间片大小需要特别注意
- 优先级调度算法：按进程的优先级选择执行顺序
- 多级反馈队列调度算法：设置多个辅助队列，每个队列优先级不同，且优先级高的时间片越小，当一个进程到来时先进第一队列(先进先出)，在时间片内如果无法执行完就到第二队列(先进先出)，以此类推，且只有当第一队列中没有进程后第二队列才能执行，这样无需提前知道进程的运行时间还能满足各类型进程的需求

## 进程间通信方式

### 管道

管道分为匿名管道(`|`)和命名管道(`mkfifo`)，匿名管道将前一个命令的输出作为后一个命令的输入，用完就销毁，而命名管道则会创建个类型为p(pipe)的文件用于数据写入和读出

管道的通信是单向的，通信的数据都遵循FIFO(不能指定offset读)，是无格字节流数据，并且传输数据的进程必须等接受数据的进程接收完数据后才能返回，否则就会一直阻塞，因此效率低下

匿名管道创建原理：通过`int pipe(int fd[2])`函数创建个只存在于内存中的特殊文件，返回读和写两个fd，接着可以通过fork子进程，子进程会复制父进程的文件描述符fd，此时父子进程都持有了读和写两个fd，接着按需要关闭父子进程各自一个fd，从而保证数据单向传输，避免混乱。如果父子进程间需要双向通信，那就需要创建两个匿名管道，分别负责父->子和子->父的数据传输

匿名管道的通信范围只能在父子进程间，而命名管道会创建类型为管道的设备文件用于数据通信，因此任何的进程都可以通过命名管道通信

比如`ls | grep 'name'`中`ls`和`grep 'name'`明显不是父子进程，但它们都是shell父进程创建出来的子进程，因此他们可以理解为兄弟进程，因此也就可以共享匿名管道的fd进行通信了

### 消息队列

消息队列是保存在内核中的消息链表，发送方和接收方确定好消息体的数据类型，因此每个消息体都是固定大小的存储块，如果不主动释放，消息队列会一直存在

消息队列存在通信不及时和大小限制的问题，linux中规定了队列的最大长度和消息的最大长度，此外在数据写入消息队列和读出消息队列存在着用户态和内核态间的数据拷贝的消耗

### 共享内存

共享内存即进程各自不同的虚拟地址映射到同一块物理地址上，这样一个进程写入的数据立刻能被另一个进程读取，即解决了消息队列中存在的用户态和内核态间的数据拷贝的消耗问题

共享内存的通信方式会带来多个进程同时修改同一块物理地址的问题，因此就需要保护机制来保证共享内存在任一时刻只能被一个进程访问，这就是信号量

信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据

控制信号量有两个原子操作P和V，P表示将信号量-1，而V表示将信号量+1，当信号量小于0后表示该资源不可用，进程被阻塞等待，大于0则表示资源可用

### 信号

上面说的进程通信方式都是在正常的工作模式下，而当异常的情况下就需要信号的方式来通信(信号和信号量没有任何关系)，信号是进程通信中唯一的

对于信号有三种处理方式：
- 默认操作：linux对每种信号都规定了默认操作，当程序不主动处理信号时就会执行默认操作
- 捕获信号：在程序中自定义某一种信号的处理函数，当信号来时就执行自定义的函数
- 忽略信号：直接忽略某些信号，不作任何处理
在所有的信号中SEGSTOP和SIGKILL两个信号是不能被捕获和忽略的，他们用于在任何时候中断或结束一个进程

`ctrl + c`会发出SIGINT信号，通知该进程和其子进程结束进程
`kill`默认的kill命令会发出SIGNTERM(15)信号，通知进程正常退出，可以被进程自己捕获处理
`kill -9`会发出SIGKILL(9)信号，这个信号是不能捕获和忽略的，因此该命令一定能保存结束该进程

### Socket

Socket可以实现跨网络的不同机器上的进程通信

Socket除了TCP和UDP以外，当通信进程在同一主机上时，可以通过本地字节流/数据报的形式进行通信，其相较于TCP和UDP不再是绑定ip和端口，而是绑定一个本地文件

### 线程间通信

同个进程下的所有线程都是共享该进程的资源的，因此只要共享的变量就可以实现线程间通信

因为线程是共享内存的，所以对于线程间通信更需要关注的是对共享资源的同步和互斥的现实，可以通过信号量实现

## 页面置换算法

- 最佳置换算法(OPT)：优先淘汰未来不再会被使用到的页面，但是因为无法预知哪些页面不再会被使用，因此该算法无法实现
- 先进先出置换算法(FIFO)：优先淘汰最先进入内存的页面，但会存在Belady异常(分配的物理块越多但出现缺页中断的次数反而增加)
- 最近最久未使用置换算法(LRU)：优先淘汰最长时间没被访问过的页面，但需要寄存器和栈的硬件支持
- CLOCK：每个页面都有一个访问位，当该页被访问就+1，淘汰时扫描所有页的访问位，优先淘汰访问位为0的页，如果没有找到则再次扫描淘汰访问位为1的页，知道淘汰掉一个为止

## 磁盘寻道算法

- 先来先服务算法(FIFO)：依次处理服务队列中每一个寻道请求，但会导致磁头移动的平均距离比较大
- 最短寻道时间算法(SSTF)：优先处理距离当前磁头所在磁道最近的磁盘号，但会导致距离当前磁道较远的磁盘号请求一直无法被服务，即饥饿现象
- 扫描算法(SCAN，电梯算法)：磁头必须移动到最外侧磁道后才能反向向内移动，在向内移动到最内侧后才能再反向向外扫描
- LOOK算法：相较于SCAN算法，磁头不再必须移动到最外/最内侧磁道后才能返回，而是移动到某处且这处之后不再有需要访问的磁盘号就立即反向移动
- C-SCAN/C-LOOK循环算法：相较于SCAN和LOOK，当移动到一侧后，不再掉头反向查找服务，而是直接调换到另一侧头开始继续服务

## 用户态/内核态

在CPU的所有指令中有一些指令是很危险的，比如清内存等，因此不能允许所有程序都能使用这些指令，因此要执行这些特权指令就必须由用户态切换为核心态

用户态和核心态在程序状态字(寄存器)中通过0/1来标志，用户态到核心态也就是个设置程序状态字标志的操作

中断是CPU从用户态到核心态的唯一途径，发生中断就意味着需要操作系统介入进行工作，比如进程切换，IO操作等x

既然由用户态到核心态只能通过中断进行，但是中断也分成内中断和外中断：
- 内中断
  - 自愿中断：也就是系统调用，用户态进程申请执行操作系统提供的特权指令
  - 强迫中断：也就是程序在用户态下发生了事先不可知的异常，这就会触发切换到内核态由操作系统进行处理
- 外中断：比如外设中断，当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时CPU就会暂停执行下一条即将要执行的指令，切换到内核态由操作系统去执行中断信号对应的处理程序

## 虚拟内存/分页/分段

分页和分段区别在于分的粒度不同，但都是为了更好的管理内存

当没有分页或分段的虚拟内存技术，程序加载到内存要求一段连续的内存地址，那么就会产生如下问题：
- 必须有连续的满足程序大小的空间地址
- 地址空间不隔离，进程可能会操作到别的进程的内存地址
- 程序运行时的地址不确定，如果在程序中写死操作某个物理地址，但无法保证程序每次加载进内存都在这块物理地址处
- 内存使用率低下，当程序移出内存后，如果这块区域太小无法容纳接下来的程序要求，那么就会造成内存碎片，此外应该可以将有些暂时不用的程序移到磁盘，让别的程序加载进内存(缺页中断)

分页/分段引入了虚拟地址空间的概念，通过将虚拟地址映射到物理地址上，从而程序只需要关心虚拟地址即可，但是分段模式下映射的还是一整块连续的内存地址(分段解决了地址空间不隔离和运行时地址不确定的问题)，但内存使用率低下的问题还是没能解决，而分页的方式，将虚拟地址分为页号和页内偏移量两部分，将内存的最小单元由一个程序所需的连续内存段转为粒度更细的页，从而有效解决了内存碎片的问题

分页通过页表记录虚拟地址和物理地址间的映射关系，页表存储在每个进程PCB中，这个页表是该进程独有的，当CPU读取数据时，需要先读一次内存中的页表，找到物理地址后才能访问到真正的数据，因此数据读取需要两次内存读取，于是就在CPU缓存中维护了个TLB快表，当查询虚拟内存地址时会先查TLB快表，如果不在再去内存中查询页表，从而加快速度

虚拟内存地址大于物理内存地址时，其实就是虚拟地址在页表中映射到了disk硬盘上，这时会发生缺页中断，此时切换到内核态，内核从磁盘中找到数据加载到内存中，并将物理地址重新填写到页表中，再重新寻址

![内存段](./pics/memory.png)

## IO模型 

![IO模型](./pics/IO.png)

阻塞IO：同步阻塞，使用系统调用，并一直阻塞直到内核将数据准备好，之后再由内核缓冲区复制到用户态，在等待内核准备的这段时间什么也干不了
非阻塞IO：同步非阻塞，内核在没有准备好数据的时候会返回错误码，而调用程序不会休眠，而是不断轮询询问内核数据是否准备好
IO多路复用：同步阻塞，类似与非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态，但可以同时监听多个文件信息
信号驱动式IO：内核在数据准备就绪时通过信号通知
异步IO：异步非阻塞，等待数据和读取数据都由内核完成了

阻塞和非阻塞：阻塞代表着请求的进程必须等待，而非阻塞代表着请求的进程可以去干别的事情而不必阻塞在这里等待
同步和异步：同步代表进程请求的结果得自行去获取，而异步则代表会有别人在拿到结果后回来通知请求的进程(回调)

## 死锁

### 死锁的四个条件

1. 资源是互斥的，同时只有一个线程可以持有
2. 占有且等待，即线程持有互斥锁的同时还在等待另一个互斥锁
3. 不可抢占，即线程持有了互斥锁后其他线程是无法强制占用该互斥锁
4. 循环等待，即A线程在等待B线程持有的互斥锁，而B线程也在等待A线程持有的互斥锁

### 处理死锁

- 占有且等待：可以要求一次性请求所有的需要的锁，阻塞这个线程直到或得到所有的锁
- 不可抢占：拒绝持有锁的进程继续申请锁，要求必须先释放锁
- 不可抢占：如果一个进程请求的锁被另一个进程持有，那么操作系统可以要求持有锁的进程释放锁
- 循环等待：为锁的分类排序，按顺序请求

### 死锁避免

- 进程启动拒绝：如果一个进程的请求会造成死锁，就拒绝启动该进程
- 资源分配拒绝：如果一个进程增加的资源请求会造成死锁，则不允许此分配
