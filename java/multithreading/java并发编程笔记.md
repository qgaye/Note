# Java并发编程笔记

## 并发编程Bug的源头

### 可见性

可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到

多核时代，每颗CPU都有自己的缓存，因此当两个线程分别在不同核上运行时，操作的是不同的CPU缓存，此时两个线程中的变量是不具备可见性的

### 原子性

原子性：一个或多个操作在CPU执行过程中不被中断，连续执行

CPU指令是符合原子性的，但高级语言的一个操作符往往包含多个CPU指令，比如一个变量+1操作，需要先将变量从内存加载到CPU寄存器中，接着在寄存器中执行+1，最后将结果写入内存，因此一个+1操作事实是代表着三个CPU指令。而操作系统做任务切换则可能在任何一条CPU指令执行完后，因此+1操作是会被操作系统中断的，从而整个+1操作是不具备原子性的

### 有序性

有序性：程序按照代码的先后顺序执行

编译器会对代码顺序进行优化，比如new操作实际顺序是先分配一块内存，接着将内存地址赋值给变量，最后再在内存上初始化对象，这和我们以为的先初始化对象再将地址赋值给变量的顺序不同，因此很可能发生变量判断不为空但事实上还没有在内存上new出对象

### 32位机器对long变量操作存在并发问题

long类型是64位，因此在32位机器上对long类型数据操作需要多条CPU指令组合来完成，因此无法保证原子性

## Java内存模型(JMM)

TODO: Java内存模型和八项Happen-Before

## 保证原子性

原子性的源头是因为线程切换，可以使用`synchronized`关键词来加上互斥锁，以保证操作是不分割的

普通方法上的`synchronized`锁的是`this`，静态方法上的`synchronized`锁的是该类的`class`，在方法的代码段中`synchronized`锁的是其后面括号里的对象

### 死锁

使用粒度越细的锁就越可能发生死锁

发生死锁的必要4个条件(必须同时满足)：
1. 资源是互斥的，同时只有一个线程可以持有
2. 占有且等待，即线程持有互斥锁的同时还在等待另一个互斥锁
3. 不可抢占，即线程持有了互斥锁后其他线程是无法强制占用该互斥锁
4. 循环等待，即A线程在等待B线程持有的互斥锁，而B线程也在等待A线程持有的互斥锁
