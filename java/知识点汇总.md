# Java知识点汇总

## switch中的String

在jdk1.7之后`switch`中也支持`String`、`Enum`和整型的包装类类型，此前支持整型的基本类型(`int`、`short`、`byte`、`char`)

其实`switch`只支持一种类型，就是整形，所有其他适用的类型都是化为整型后进行(`char`实际上比较的是`ASCII`码)

### 实现代码

`switch`实际比较的是`hashCode`(整型)，然后由于会发生哈希冲突，所以还要进行`equals()`判断

```java
String key = "first";
String s;
switch((s = key).hashCode()) {
    case 19298384742:
        if (s.equals("first")) {
            // 匹配成功
        }
        break;
    case 34123564363:
        if (s.equals("second")) {
            // 匹配成功
        }
        break;
    default:
        break;
}
```


## 关键字transient

在序列化和反序列化中，被`transient`修饰的字段会被屏蔽，从而对指定的需要持久化的字段进行[序列化](#序列化)

```java
private transient String age;
```

在序列化该类时，将不会序列化`age`字段，从而达到省略持久化不必要字段的作用

在被`transient`修饰的字段不会被序列化，因此在[反序列化](#序列化)时，该字段的是其类型的默认值

## 序列化

- 序列化：将对象写入到IO流中
- 反序列化：从IO流中恢复对象

序列化和反序列化机制使得java对象可以转换为字节序列，这些字节序列在可以保存在本地磁盘和在网络上传输，并能够恢复成原来的对象。序列化机制使得对象能够脱离程序的运行而独立存在

### 序列化的实现

#### 1. Serializable

Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的

序列化步骤：
1. 创建一个ObjectOutputStream输出流
2. 调用ObjectOutputStream对象的writeObject输出可序列化对象

反序列化步骤：
1. 创建一个ObjectInputStream输入流
2. 调用ObjectInputStream对象的readObject()得到序列化的对象

- 序列化对象的引用类型成员变量，也必须是可序列化的
- 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化
- 反序列化的顺序和序列化的顺序一致
- 使用[transient](#关键字transient)关键词自定义序列化

#### 2. Externalizable

实现`Externalizable`接口，必须实现`writeExternal`、`readExternal`两个方法

虽然使用`Externalizable`接口可以让程序员决定序列化过程中存储的信息，并且性能更好，但是由于实现`Serializable`接口后，java内建支持了序列化，更为方便，因此更多使用`Serializable`接口

## serialVersionUID

java序列化提供了一个`private static final long serialVersionUID`的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来

如果反序列化使用的class的版本号与序列化时使用的不一致，反序列化会报`InvalidClassException`异常

序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化

### 修改serialVersionUID的三种情况

- 如果只是修改了方法，反序列化不受影响，则无需修改版本号
- 如果只修改了静态变量或`transient`修饰的变量，反序列化也不受影响，也无需修改版本号
- 如果修改或新增或删除了非静态和`transient`变量，则反序列化受到影响，必须修改版本号

## 浮点数

```java
0.5 == 1 - 0.5;  // false
0.9 == 1 - 0.1;  // true
```

以上两个式子很明显在数学计算上是相等的，但是为什么一个返回的是true而另一个则是false？

首先十进制转二进制是将每个数x2取其进位的顺序排序组成的，因此`0.5`是可以在有限位被表示的，而`0.1`是会被计算成一个无限循环的，是无法在有限位中被表示的，又因为计算机中无论`float`还是`double`都是有限位长的，因此`0.1`是无法准确表示`0.1`，因此减出来的值也是不同的

### 浮点数比较

- 在浮点数比较时，设定一个阀，比如`1 - 0.1 - 0.9 < 0.0000001`
- 使用java中的`BigDecimal`进行浮点运算，注意初始化时使用字符串而不是浮点数，因为浮点数存在精度丢失问题，初始化后的`BigDecimal`依旧会存在问题

### strictfp

在浮点数操作中，由于不同平台间存在精度不同问题，因此`strictfp`关键词确保浮点数操作能在各个平台都获得相同结果

- 可以应用于方法，类和接口
- 不能应用于抽象方法，变量或构造函数

### 变量赋值尾缀

在java赋值中，`long`、`float`、`double`在赋值量后面分别添加`L`(小写`l`的容易和`1`混淆，因此用大写`L`)、`f`、`d`

不添加尾缀，虚拟机也会直接将整数数据`int`自动转换为对应类型然后赋值，而浮点数则会默认为`double`

```java
// int自动转型为long、float、double
long a = 1;
float a = 1;
double a = 1;
// 报错，浮点数默认double类型
float a = 1.1;
// 不报错
double a = 1.1;
```

### IEEE754

IEEE754是二进制浮点数算术标准

在IEEE754中可以理解为所有数字都用科学计数法来表示，即存在指数和小数

![32位IEEE754表示](./pics/IEEE754.png)

如图是32位的IEEE754表示，一位符号位，8位阶码(指数的移码)，剩余23位为分数

## 参考资料

- [JAVA中transient关键字的使用](https://www.jianshu.com/p/19ba0764bfbd)
- [java序列化，看这篇就够了- 掘金](https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf)