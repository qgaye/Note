# Redis笔记

## 数据类型和底层数据结构

Redis使用全局哈希表来保存所有的键值对，全局哈希表中value保存的是(key, value)的键值对的指针

![全局哈希表](./pics/global_hash_table.jpg)

当key出现哈希冲突时，在全局哈希表中会通过链地址法(即哈希冲突的entry会以链表的形式保存)，那么此时当查询到哈希冲突的key时就需遍历整个链表才能找到所查找的entry，链表的遍历是O(n)，所以就非常耗时

此时Redis就会对全局哈希表做rehash动作，为了使rehash操作更高效，Redis默认使用两个全局哈希表并采用渐进式rehash。全局哈希表1和全局哈希表2，当一开始插入数据时都插入全局哈希表1，当需要rehash时：
1. 首先给哈希表2分配更大的空间(即增加桶的数量减少哈希冲突的情况)
2. 然后并不是直接把哈希表1中的数据全部拷贝到哈希表2(因为做全量拷贝时就会造成Redis线程阻塞而无法服务其他请求)，而是Redis仍正常处理客户端请求，每处理一个请求时将哈希表1中第一个索引(即桶)上的所有entry拷贝到哈希表2，然后等到处理下一个请求再将哈希表1中第二个索引上的所有entry全部拷贝到哈希表2，以此类推
3. 最后等到哈希表1中全部拷贝到了哈希表2后，释放哈希表1中空间

通过渐进式rehash，将一次性的大量拷贝的开销，分摊到多次处理过程中，保证了Redis的快速响应

- String：简单动态字符串
- List：双向列表 + 压缩列表
- Hash：哈希表 + 压缩列表
- Sorted Set：跳表 + 压缩列表
- Set：整数数组 + 压缩列表

压缩列表：其类似一个数组，但和数组不同的是，压缩列表在表头有三个字段zlbytes，zltail和zllen，分别表示列表长度，列表尾的偏移量和列表中entry个数，压缩列表中表尾还有个zlend，表示列表结束。压缩列表的优势在于如果要查找第一个元素和最后一个元素都是O(1)的，并且查询元素个数也是O(1)，但对于其他元素的查找就还是O(N)

![压缩列表](./pics/compressed_list.jpg)

跳表：其在链表的基础上，增加多级索引，通过索引位置的跳转实现数据的快速定位，整个查询过程就是在多级索引上跳来跳去，因此叫做跳表，跳表查找的时间复杂度为O(logN)

![跳表](./pics/skip_list.jpg)

对于所有Redis的操作来说，对单个元素的操作基本都是O(1)，比如HGET，HSET，SADD，SREM等；对于范围操作，比如HGETALL，SMEMBERS等返回集合中所有数据的操作，是需要遍历整个集合的，复杂度一般都为O(N)，因此尽量避免；对于统计操作，比如LLEN，SCARD统计集合中元素个数的复杂度都是O(1)，Redis可以高效完成；此外比如对集合首尾元素的操作，因为压缩列表的支持，复杂度也只有O(1)

## 单线程

Redis的单线程主要是指Redis的网络IO和键值对读写是由一个线程完成的，这也是Redis对外提供键值存储服务的主要流程。但Redis的其他功能，比如持久化，异步删除，集群数据同步等，其实是由额外的线程执行的

单线程模式避免了多线程下共享资源的并发访问控制的问题

此外Redis使用到了IO多路复用的能力，由内核负责监听套接字上的连接请求和数据请求，一旦请求到了，就会通过回调的方法交给Redis线程处理，而不再会被阻塞在套接字上(比如阻塞在`recv()`上)

![IO多路复用](./pics/multiplexing.jpg)

但单线程处理模式也存在个两个方面的问题：
1. Redis单线程中任意一个请求耗时(比如操作bigkey)会影响到后面的所有请求，进而影响整个Redis的性能。需要业务人员自行去规避
2. 并发量大时，单线程读写客户端数据存在性能瓶颈，虽然IO多路复用是非阻塞的，但单线程读写客户端数据是阻塞的。在Redis6.0中可以在高并发场景下通过多线程读写客户端数据，但真正键值对的读写还是由单线程完成

## 
